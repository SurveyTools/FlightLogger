package com.vulcan.flightlogger;

import java.io.File;
import java.sql.Date;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;

import com.vulcan.flightlogger.util.SystemUiHider;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

public class FlightLogger extends Activity implements LocationListener {
	
	private final String LOGGER_TAG = FlightLogger.class.getSimpleName();
	
	private LocationManager locationManager;
	private boolean gpsEnabled;
	
	// need to get a better number in here to save battery life, once testing in the air
	private static final float MIN_DISTANCE_CHANGE_FOR_UPDATES = 0; 

	// need to revisit this guy, to see if we need more accuracy. Currently they sample at 30 seconds
	private static final long MIN_TIME_BETWEEN_UPDATES = 1000 * 3;
	
	// refs to our ui controls, so we don't do a resource lookup each time
	TextView latTV, lonTV, altTV, speedTV, accuracyTV, timeTV;
	
	// Autohide stuff, generated by the Eclipse project
	private static final boolean AUTO_HIDE = true;
	private static final int AUTO_HIDE_DELAY_MILLIS = 3000;
	private static final boolean TOGGLE_ON_CLICK = true;
	private static final int HIDER_FLAGS = SystemUiHider.FLAG_HIDE_NAVIGATION;
	private SystemUiHider mSystemUiHider;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setContentView(R.layout.activity_flight_logger);

		final View controlsView = findViewById(R.id.fullscreen_content_controls);
		final View contentView = findViewById(R.id.fullscreen_content);
		
		initGps();
		
		initAltimeter();
		
		bindUIControls(); 

		// Autohide the parent controls, to maximize monitor space when running
		mSystemUiHider = SystemUiHider.getInstance(this, contentView,
				HIDER_FLAGS);
		mSystemUiHider.setup();
		mSystemUiHider
				.setOnVisibilityChangeListener(new SystemUiHider.OnVisibilityChangeListener() {
					// Cached values.
					int mControlsHeight;
					int mShortAnimTime;

					@Override
					@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
					public void onVisibilityChange(boolean visible) {
						if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
							// If the ViewPropertyAnimator API is available
							// (Honeycomb MR2 and later), use it to animate the
							// in-layout UI controls at the bottom of the
							// screen.
							if (mControlsHeight == 0) {
								mControlsHeight = controlsView.getHeight();
							}
							if (mShortAnimTime == 0) {
								mShortAnimTime = getResources().getInteger(
										android.R.integer.config_shortAnimTime);
							}
							controlsView
									.animate()
									.translationY(visible ? 0 : mControlsHeight)
									.setDuration(mShortAnimTime);
						} else {
							// If the ViewPropertyAnimator APIs aren't
							// available, simply show or hide the in-layout UI
							// controls.
							controlsView.setVisibility(visible ? View.VISIBLE
									: View.GONE);
						}

						if (visible && AUTO_HIDE) {
							// Schedule a hide().
							delayedHide(AUTO_HIDE_DELAY_MILLIS);
						}
					}
				});

		// Set up the user interaction to manually show or hide the system UI.
		contentView.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				if (TOGGLE_ON_CLICK) {
					mSystemUiHider.toggle();
				} else {
					mSystemUiHider.show();
				}
			}
		});
	}
	
	/**
	 * Action menu handling
	 */
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
	    // Inflate the menu items for use in the action bar
	    MenuInflater inflater = getMenuInflater();
	    inflater.inflate(R.menu.main_activity_actions, menu);
	    return super.onCreateOptionsMenu(menu);
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		// action with ID action_refresh was selected
			case R.id.action_use_laser_alt:
			  Toast.makeText(this, "Laser enabled selected", Toast.LENGTH_SHORT)
			      .show();
			  break;
			// action with ID action_settings was selected
			case R.id.action_serial_discovery:
			  Toast.makeText(this, "Serial discovery selected", Toast.LENGTH_SHORT)
			      .show();
			  break;
			case R.id.action_load_gpx:
				ArrayList<File> gpxFiles = FilesystemMgr.listGPXFiles();
				for (File gpxFile:gpxFiles)
				{
					Log.d("foo", gpxFile.getName());
				}
			      break;
default:
  break;
}

	    return true;
	  } 
	
	private void bindUIControls() {
		latTV = (TextView)findViewById(R.id.gpsVal1); 
		lonTV = (TextView)findViewById(R.id.gpsVal2); 
		altTV = (TextView)findViewById(R.id.gpsVal3); 
		speedTV = (TextView)findViewById(R.id.gpsVal4); 
		timeTV = (TextView)findViewById(R.id.gpsVal5); 
		accuracyTV = (TextView)findViewById(R.id.gpsVal6);
	}


	/**
	 * Altimeter 
	 */
	private void initAltimeter() {
		
	}
	
	/**
	 * GPS 
	 */
	
	private void initGps()
	{
		locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
		// getting GPS status
        boolean isGPSEnabled = locationManager
                .isProviderEnabled(LocationManager.GPS_PROVIDER);

        if (isGPSEnabled) 
        {
            locationManager.requestLocationUpdates(
                    LocationManager.GPS_PROVIDER,
                    MIN_TIME_BETWEEN_UPDATES,
                    MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
            Log.d(LOGGER_TAG, "GPS Enabled");
        }
        else 
        {
        	showGpsFailureAlert();
        	Log.d(LOGGER_TAG, "GPS not enabled");
        }
	}
	
	@Override
	public void onLocationChanged(Location location) 
	{
		latTV.setText(Location.convert(location.getLatitude(), Location.FORMAT_DEGREES));
		lonTV.setText(Location.convert(location.getLongitude(), Location.FORMAT_DEGREES));
		altTV.setText(formatAltitude(location.getAltitude()));
		speedTV.setText(String.valueOf(location.getSpeed()));
		accuracyTV.setText(String.valueOf(location.getAccuracy()));
		timeTV.setText(convertGPSTime(location.getTime()));
	}
	
	private String convertGPSTime(long gpsTime)
	{
		// TODO: see if SimpleDateFormat and Date are expensive
		Date date = new Date(gpsTime);
		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss z");
		String text = sdf.format(date);
		return text;
	}
	
	private String formatAltitude(double altVal)
	{
		DecimalFormat df = new DecimalFormat("#.##");
		return df.format(altVal);
	}

	@Override
	public void onProviderDisabled(String arg0) {
		Log.d(LOGGER_TAG, "GPS provider disabled");
		
	}

	@Override
	public void onProviderEnabled(String arg0) {
		Log.d(LOGGER_TAG, "GPS provider enabled");
	}

	@Override
	public void onStatusChanged(String arg0, int arg1, Bundle arg2) {
		Log.d(LOGGER_TAG, "GPS status changed");
		
	}

	public boolean isGpsEnabled() {
		return gpsEnabled;
	}

	public void setGpsEnabled(boolean isEnabled) {
		this.gpsEnabled = isEnabled;
	}
	
	public void showGpsFailureAlert()
	{
		new AlertDialog.Builder(this)
	    .setTitle("GPS Error")
	    .setMessage("The GPS system failed to initialize. Would you like to try again?")
	    .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
	        public void onClick(DialogInterface dialog, int which) { 
	            initGps();
	        }
	     })
	    .setNegativeButton(android.R.string.no, new DialogInterface.OnClickListener() {
	        public void onClick(DialogInterface dialog, int which) { 
	            // do nothing
	        }
	     })
	    .setIcon(android.R.drawable.ic_dialog_alert)
	     .show();
	}

	/**
	 * Hide status bars to maximize space
	 */
	View.OnTouchListener mDelayHideTouchListener = new View.OnTouchListener() {
		@Override
		public boolean onTouch(View view, MotionEvent motionEvent) {
			if (AUTO_HIDE) {
				delayedHide(AUTO_HIDE_DELAY_MILLIS);
			}
			return false;
		}
	};
	
	@Override
	protected void onPostCreate(Bundle savedInstanceState) {
		super.onPostCreate(savedInstanceState);
		// Trigger the initial hide() shortly after the activity has been
		// created, to briefly hint to the user that UI controls
		// are available.
		delayedHide(100);
	}

	Handler mHideHandler = new Handler();
	Runnable mHideRunnable = new Runnable() {
		@Override
		public void run() {
			mSystemUiHider.hide();
		}
	};

	private void delayedHide(int delayMillis) {
		mHideHandler.removeCallbacks(mHideRunnable);
		mHideHandler.postDelayed(mHideRunnable, delayMillis);
	}
	
}
